/* Non-recusive multiple definition. */
let x = 15
and y = 25
and z = true;

/* Recursive multiple definition. */
let rec f = fun () => { 15; }
and g = fun () => { f() + 20; }
and h = fun (i) => { if (i > 0) { g() + h(i - 1); } else { g(); }; };

/* Recursive single definition. */
let rec k = fun (b) => { if (b) { k(false); } else { b; }; };

let int_find = fun {x : int} => { x; };

/* Variable non-escape test. */
let rec f = fun (_) => { int_find; };

let a = fun () => {
  let a = f(true);
  let b = f(1);
  let c = f();
  (a, b, c);
};

/* Harsher variable non-escape test. */
let rec f = fun (a) => { if (int_find > 0) { a; } else { failwith("No"); }; };

let a = fun () => {
  (f(true), f(1), f());
};

/* Recursive multiple definition with implicit variables. */
let rec f = fun () => { int_find; }
and g = fun () => { f() + f(); };

instance int_instance = 15;

let h = g();

/* Traditional while construct. */
let rec while_ = fun (pred, body) => {
  if (pred()) {
    body();
    while_(pred, body);
  };
};

/* Recursive let in an expression body. */
let count_down_from = fun (i) => {
  let rec go = fun (i) => {
    if (i > 0) {
      go(i - 1);
    };
  };
  go(i);
};
