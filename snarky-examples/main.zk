/* This example isn't meant to be prescriptive about scoping, syntax, names, etc.
   It's just a rough idea of what should be possible. */

type quadruple('a) = ('a, 'a, 'a, 'a);
type triple('a) = ('a, 'a, 'a);
type double('a) = ('a, 'a);

/*
- Prover doesn't work (needs read Field.typ inserted)

- have to do 
  assert_r1cs(?label=None, lambda, lambda, cx + ax + bx);
  label not getting erased
  - delete the labelled version from snarky
- toplevel cli
- write meja
  -> add hard coded code that calls the functor
  -> maybe some more parsing for public inputs or something

me
- list with length thing
- Field.of_string
- reproduce: Field.Field.t type error
- documentation and a plan for monday
- translate more functions into meja
- I'll try handlers

- show them this example, walk thru it
  - tutorial examples with holes, they can fill it in
  - simple "problem", from scratch (no holes)

bonus
- batch compile (use dune)
- arrow type syntax is a bit inconsistent, i'd expect the types to be
  (a1, .., an) -> b or even
  (a1, .., an) => b
- Cannot unify bytes and string
  let s : string = String.create(0i);
- if then else
- recursion
    /* Could be Prover { ... } instead of Prover {fun () => ... } */
- array access syntax
- Bug with two optional args in a row
  exists(
    /* Could be Prover { ... } instead of Prover {fun () => ... } */
    ~compute= Prover { fun () => { Field.(+)(/* should insert calls to read_var here */  lambda, s); }; }
  );
*/

module UInt32 = {
  let length = 32i;

  type t = list(boolean);

  let xor : t -> t -> t = fun (t1, t2) => {
    List.map2(Boolean.lxor, t1, t2);
  };

  let zero : t = List.init(length, fun (_) => { 0b; });

  let ceil_log2 = loop(fun (self, n) => {
    switch (n) {
      | 0i => 0i
      | _ => 1i + self(n / 2i)
    };
  });

  let max_int32 = 4294967295i;

  let take = fun (n, xs) => {
    let (xs, _) =
      List.fold_left(fun ((xs, k), x) => {
        switch (k >= n) {
          | true => (xs, k)
          | false => (x :: xs, k + 1i)
        };
      }, ([], 0i), xs);
    List.rev(xs);
  };

  let sum : list(t) -> t = fun (xs) => {
    let max_bit_length : int = ceil_log2(List.length(xs) * max_int32);
    let xs_sum =
      List.fold_left(
        fun (acc, x) => {
          Field.(+)(Field.of_bits(x), acc);
        }, 
        0,
        xs);
    take(
      32i,
      // TODO: Shouldn't have to put Some here
      Field.to_bits(~length=max_bit_length, ?allow_overflow=Some(false), xs_sum));
  };

  let rotr : t -> int -> t = fun (t, by) => {
    let t = Array.of_list(t);
    Array.to_list(
      Array.init(length, fun (i) => {
          Array.get(t, (mod(i + by, length))); }));
  };

  let int_get_bit = fun (n : int, i : int) => {
    switch(land(lsr(n, i), 1i)) {
      | 1i => 1b
      | _ => 0b
    };
  };

  let of_int : int -> t = fun (n) => {
    loop( 
      fun (self, (i, acc)) => {
        switch (i) {
          | 32i => acc
          | _ =>
            self((i + 1i,  int_get_bit(n, (31i - i)) :: acc))
        };
      },
      (0i, [])
    );
  };
};

module Blake2 = {
  let r1 = 16i;

  let r2 = 12i;

  let r3 = 8i;

  let r4 = 7i;

  let mixing_g = fun (v, a, b, c, d, x, y) => {
    let ( = ) = fun (i, t) => { Array.set(v, i, t); };
    let (!) = Array.get(v);
    let sum = UInt32.sum;
    let xorrot = fun (t1, t2, k) => {
      UInt32.rotr(UInt32.xor(t1, t2), k);
    };
    a = sum([!a, !b, x]) ;
    d = xorrot( !d, !a, r1 );
    c = sum([!c, !d]);
    b = xorrot( !b, !c, r2 );
    a = sum([ !a, !b, y]);
    d = xorrot(!d, !a, r3);
    c = sum([!c, !d]);
    b = xorrot(!b, !c, r4);
  };

  let iv =
    Array.map(
      UInt32.of_int,
      Array.of_list(
        [ 1779033703i
        , 3144134277i
        , 1013904242i
        , 2773480762i
        , 1359893119i
        , 2600822924i
        , 528734635i
        , 1541459225i ]))

/*
  let sigma =
    [| [|0i, 1i, 2i, 3i, 4i, 5i, 6i, 7i, 8i, 9i, 10i, 11i, 12i, 13i, 14i, 15i|]
     , [|14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3|]
     , [|11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4|]
     , [|7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8|]
     , [|9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13|]
     , [|2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9|]
     , [|12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11|]
     , [|13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10|]
     , [|6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5|]
     , [|10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0|] |]
    */

};

module Curve = {
  let ( + ) = Field.( + );
  let ( - ) = Field.( - );
  let ( * ) = Field.( * );

  // Would be nice to have "subset syntax" for the Typ for this type.
  type t = double(field);

  let div_unsafe = fun (x, y) => {
    let z = exists( ~compute=Prover {fun () => { 
        // Doesn't work
        // Field.(/)(x, y); 
        x;
      }; 
      }, ?request=None ) ;
    assert_r1cs(?label=None, x, y, z) ;
    z;
    /* It would be nice if this were a special syntax but that's
        a "nice to have" */
    /* assert (x * y == z); */
  };

  let add_unsafe = fun ((ax, ay), (bx, by)) => {
    /* Maybe  have (-) be for field elts ? */
    let lambda = div_unsafe(Field.(-)(by, ay), Field.(-)(bx, ax));
    let cx =
      exists(
        /* Could be Prover { ... } instead of Prover {fun () => ... } */
        ?request=None, /* Shouldn't have to provide this ideally */
        ?compute= Some ( Prover { fun () => { lambda; /* Field.(+)(lambda, s); */ }; } ) /* ~compute=.. didn't work */
      );
    assert_r1cs(?label=None, lambda, lambda, cx + ax + bx);
    let cy =
      exists(
        ~compute=Prover {fun () => {
            // Doesn't work (needs read Field.typ inserted)
            // Field.{ lambda * (ax - cx) - ay; }; 
            lambda ;
          };
          },
        ?request=None
      );
    // assert (lambda * (ax - cx) == (cy + ay));
    assert_r1cs (?label=None, lambda , (ax - cx) , (cy + ay));
    (cx, cy);
  };

};

module Pedersen = {
  module Digest = {
    type t = field;
  };

  module Params = {
    type t = array(quadruple((field, field)));
  };

let params = {
    let comma = char_of_int(44i);
    let semi_colon = char_of_int(59i);

    let read_pair = fun (s) => {
      switch (String.split_on_char(comma, s)) {
        | [ x, y ] =>
          (Field.of_string(x), Field.of_string(y))
      };
    };

    let strs = Array.of_list(In_channel.read_lines("bn128-params"));

    Array.map(fun (s) => {
      switch ( List.map(read_pair, String.split_on_char(semi_colon, s)) ) {
        | [x1, x2, x3, x4] => (x1, x2, x3, x4)
      };
    }, strs);
  };

  /* 4 * 2 = 2 * 4 */
  let transpose : quadruple(double('a)) -> double(quadruple('a)) =
    fun ( ((x0, y0), (x1, y1), (x2, y2), (x3, y3)) ) => {
      ( (x0, x1, x2, x3), (y0, y1, y2, y3) );
    };

  let add_int = ( + );

  open Field;

  let lookup = fun ((s0, s1, s2) : triple(boolean), q : quadruple(Curve.t)) => {
    let s_and = Boolean.(&&)(s0, s1) ;
    let bool : boolean -> field = Boolean.to_field;
    let lookup_one = fun ((a1, a2, a3, a4)) => {
      a1
      + ((a2 - a1) * bool(s0)) /* Need some way to make booleans field elements */
      + ((a3 - a1) * bool(s1))
      + ((a4 + a1 - a2 - a3) * bool(s_and));
    };
    let (x_q, y_q) = transpose(q);
    (lookup_one(x_q), (1 - 2 * bool(s2)) * lookup_one(y_q)); 
  };

  let digest = fun (triples : list(triple(boolean))) : Digest.t => {
    switch (triples) {
      | [] => failwith("Cannot handle empty list")
      | (t::ts) => {
        let (_, (x, _y)) =
          List.fold_left (fun ((i, acc), t) => {
              (add_int(i, 1i),
                Curve.add_unsafe(
                  acc,
                  lookup(t, Array.get(params, i))) );
            }, (1i, lookup(t, Array.get(params, 0i) )), ts);
        x;
      }
    };
  };

  type three('a) =
    | Zero
    | One ('a)
    | Two ('a, 'a);

  let group3 = fun (xs) => {
    let default=0b;
    let (ts, r) =
      List.fold_left (fun ((ts, acc), x) => {
          switch (acc) {
            | Zero => (ts, One(x))
            | One(x0) => (ts, Two(x0, x))
            | Two(x0, x1) => ((x0, x1, x) :: ts, Zero)
          };
        },
        ([], Zero),
        xs
      );
    let ts =
      switch(r) {
        | Zero => ts
        | One(x0) => (x0, default, default) :: ts
        | Two(x0, x1) => (x0, x1, default) :: ts
      };
    List.rev(ts);
  };

  let digest_bits = fun (bs) => { digest(group3(bs)); };
};

module Merkle_tree = {
  type tuple('a) = ( 'a , 'a , 'a);
  type address = tuple(boolean);
  type path = tuple(field);

  request(path) Get_path(address);

  // The path should have the neighbors from bottom to top
  // The address should have the bits from bottom to top
  let implied_root =
    fun (leaf, (path: list(field)), addr) => {
      List.fold_left2 (fun (acc : field, neighbor, b) => {
          Pedersen.digest_bits(
            Field.to_bits(acc) @ Field.to_bits(neighbor));
        },
        leaf,
        path,
        addr);
    };

  let find = fun (addr : address) : unit => {
    let path = request { Get_path(addr); };
    ();
  };

      /*
  let get_path : unit -> list(field) = fun () => {
    let z = exists(~request= Prover { Get_path; } );
    [];
  };
    */
};
